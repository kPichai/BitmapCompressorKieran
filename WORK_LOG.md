Name: Kieran Pichai

| Date   |       Time        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Update |
|:-------|:-----------------:|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Nov 18 |  1:15pm - 1:45pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        During this segment in class I thought of initial solutions to this problem. The most obvious one seemed to be doing something like if you see XXXXX then changing that to 5X. This could be done with ones and zeroes such that if you have 00000000 that turns into 0\1000 (1 or 0/number of repetitions). |
| Nov 19 | 9:30pm - 10:20pm  |                                                                         I then worked on applying the code above, similarly while completing this I realized another issue: that what if we are actually increasing the amount of memory if we don't have any long repeat strings. Thus I allocated a 2nd bit up front on our byte that indicates whether this data is being comrpessed or not. I essentially coded this part of the pest by reading in boolean by boolean (bit by bit) then keeping track of a count of how many consecutive runs of a single bit you are on. If your count ends before 7 (where you dont want to compress bc then you will actually increase total data size) then you use the method above with an additional bit up front indicating whether the following bits is a compressed sequence or not. Otherwise, you loop until you hit the maximum of 2^6-1 then write the compressed byte to the output file. This code ensures that we have enough information to losslessly expand the compressed file later on. |
| Nov 19 | 10:20pm - 10:35pm |                                                                                                                                                                                                                                                                                                                                                                                                                                                             During this segment I tested my code and fixed a super small bug which was that at each point in the while loop I was closing the stdout file by mistake. This is why when I tested my code my compressed file had 0 bits. I then fixed this small issue and tested it on both q32x48 and q64x96 test cases. For the smaller one I acheieved a compression ratio of 67%, for the medium test case I achieved a compression ratio of 38%. This isn't near a 30% compression ratio yet so I have to think about a more efficient way to create this code such that I can compress better. |
| Nov 20 | 10:55am - 11:55am |  During this session (during class), I talked to Mr. Blick about my solution and figured out ways to address glaring issues. One issue I was having was that when I expanded my function I always ended up with less bits then I had started with. This is partially due to a few issues: what I chose to compress and not compress, and how I handled edge cases. My original failure was that I only compressed things that had repeats of longer than 6. However, I had to change this to longer than repeats of 8 because this is the correct way to consider the case (I only ever compress anything to one bit). Additionally, I was only ever reading in byte by byte which meant that I could have some extra padded 0s at the end. One way me and Mr. Blick suggested fixing that with is I could write a 3 bit "char" to the top of the file each time which indicates how many padded / ignored 0's there should be at the end. This would help remove the edge case and ould also ensure we read in the right amount of bits each time. |
